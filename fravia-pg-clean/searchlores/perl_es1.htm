<HTML>
<HEAD>
<TITLE>perl_es1.htm:    Perl@usa.net: How to reverse a "free" service
</TITLE>
</HEAD>
<BODY bgcolor="#C0C0C0" text="#001010" vlink="#405040" alink="#00FF50">
<TABLE CELLPADDING="1" CELLSPACING="2" BORDER="1" 
WIDTH= "100%"  HEIGHT="22">
<TR><td></td><td>
<!-- Choose  a TITLE and a subtitle, choose well! -->
<center><FONT SIZE="+2">
Perl@usa.net
</fonT><br><FONT SIZE="+1">
How to reverse a "free" service
</fonT></center></td><td>
<!-- Choose  a PROJECT GIF, leave this if unsure -->
<center><a href="remobann.htm"><img SRC="images/antiadv.gif" 
ALT="removing banners" ALIGN=CENTER WIDTH=114 HEIGHT=43 BORDER=0 VSPACE=0 
HSPACE=0></a><br><font color=gray>Removing banners</FonT>
</center></td></tr><tR><td bgcolor="#FFFFEA"><center><FONT COLOR="890000">
<!-- CHOOSE A DATE (will probably be changed) -->
16 July 1999
</FONT></center></td><td bgcolor="#FFFFEA"><center>by <font size=+3>
<!-- CHOOSE A HANDLE , i.e. your pseudo (wont be changed) -->
[blue]
</fonT></center></td><td VALIGN="center" bgcolor="#FFFFEA">

</td></tr><TR><td><center><a href="index.htm" ><img SRC="images/bulletr.gif" ALIGN="BOTTOM" 
BORDER="0" VSPACE="0" HSPACE="0" width="13" height="13"></a></center></td>
<TD BGCOLOR="898030"><center>Courtesy of Fravia's searchlores.org</center> 
</center></TD><td BGCOLOR="898030"><center>

</center></td></TR>
<!-- this is for the data.....fra_00xx....yymmdd....handle..beg+int...not ass... -->
<tr><td><font color="#C4C0CF">fra_00xx<bR>981607<br>[blue]<br>1000<br>AA<br>RB<br></fonT></td><td><i><center>
Woah! I'm very happy to have received this beautiful essay by [blue]<br>
This is relevant both for the <a href="bots.htm">bots</a> section and the 
<a href="antiadve.htm">anti-advertisement</a> section.<bR>
I didn't think, when I began my anti-advertisement section, that so many results would have 
been possible in such a short time. This web of hours is truly wondrous! The various 
removing banners techniques described in our <a href="remobann.htm">Removing banners</a> section will 
give anyone with an inquiring mind enough material to surf unsulled by vulgar advertisement.<br>
[blue]'s essay is a very nice introduction to 'active-perl' activities. I expect from him 
and from all my anti-banners ingenious friends even more! Let's annoy the banner-morons at 
least as much as they annoy us!
</i></center></td><td><center><a href="bots.htm"><img SRC="images/antiadv.gif" 
ALT="bots" ALIGN=CENTER WIDTH=114 HEIGHT=43 BORDER=0 VSPACE=0 
HSPACE=0></a><br><font color=gray>Bots</FonT>

<br>~<br>
<a href="antiadve.htm"><img SRC="images/antiadv.gif" 
ALT="Anti-advertisement" ALIGN=CENTER WIDTH=114 HEIGHT=43 BORDER=0 VSPACE=0 
HSPACE=0></a><br><font color=gray>Anti-advertisement</FonT>
</center>


</td></tr><TR><td></td>
<!-- Leonard Coehn's old song, because we are poets, not only crackers -->
<TD BGCOLOR="898030"><center></i><b>There is a crack, a crack in everything 
That's how the light gets in</b></center>
<!-- Leonard Coehn's old song, because we are poets, not only crackers -->
</center></TD><td></td></TR><TR><td VALIGN= "MIDDLE" 
bgcolor="#C6E7C6"><font color=blue><center>Rating</FONT></FONT></center>
</TD><td VALIGN = "MIDDLE" bgcolor="#C6E7C6"><font color=blue><center>
<!-- CHOOSE A RATING (may be changed) -->
(x)<B>Beginner</B> ( )<B>Intermediate</B> ( )<B>Advanced</B> ( )<B>Expert</B></FONT>
</center></td><td></td></tr></table>
<!-- END HEAD  --><bR>
<!-- CORPUS  -->
<!-- CHOOSE A COMMENT (may be changed)  -->
Perl is for Internet like assembly for programs: a razor sharp blade,
which any reverser should be able to use.
<hR><center><FONT SIZE="+2">
<!-- Repeat your TITLE  -->
Perl@usa.net
   </FONT><BR>
   <FONT SIZE="+2">
<!-- Repeat your SUBTITLE -->
How to reverse a "free" service
   </FONT><BR><FONT COLOR="0B7FC1">
<!-- REPEAT YOUR CHOSEN HANDLE HERE -->Written by 
[blue]
</FONT></center><br><br>

<!-- INTRO STARTS HERE -->
<TABLE CELLPADDING="1" CELLSPACING="2" BORDER="1" WIDTH= "100%"  HEIGHT="22" >
<tr><td bgcolor="#C6E7C6"><center><font size=+2><font color=blue>Introduction</fonT>
</fonT></center></td></tr></table>
<BR>
This essay shows how to use the most powerful Internet programming tool, <B>Perl</B>
to create our own e-mail client for use with Net@ddress to get our email without 
browsing all those advertisements pages. By doing this you'll learn how to use Perl to 
get HTML pages, parse them, POST data and how to use regular expressions to extract 
valuable information buried in HTML tags.
<BR>
To understand this you must have at least basic knowledge of Perl, HTML, HTTP and 
java-script (some OOP knowledge would help with some Perl modules).

<!-- PASTE HERE YOUR INTRODUCTION -->
<br><br>

<!-- TOOLS STARTS HERE -->
<TABLE CELLPADDING="1" CELLSPACING="2" BORDER="1" WIDTH= "100%"  HEIGHT="22" >
<tr><td bgcolor="#C6E7C6"><center><font size=+2><font color=blue>Tools required</fonT>
</fonT></center></td></tr></table>

<!-- PASTE HERE YOUR REQUIRED TOOLS -->
<br>
<UL>
<LI>Java script enabled browser (any browser)
<LI>Lynx (not really needed): lynx.browser.org
<LI>Perl
  <UL>
  <LI>Perl home page: www.perl.org
  <LI>Perl for Win32: www.activestate.com
  <LI>CPAN (Perl Archives): www.cpan.org
  </UL>
</UL>

If you have problems getting and installing Perl write to me and I'll help you (or
better read the damn docs).
<br><br>

<!-- TARGET URL STARTS HERE -->
<TABLE CELLPADDING="1" CELLSPACING="2" BORDER="1" WIDTH= "100%"  HEIGHT="22" >
<tr><td bgcolor="#C6E7C6"><center><font size=+2><font color=blue>Target's URL/FTP</fonT>
</fonT></center></td></tr></table>
<!-- DON'T FORGET TO PASTE HERE THE URL/FTP OF YOUR TARGET(S) -->
<br>
www.netaddress.com
<br><br>

<!-- PROGRAM HISTORY STARTS HERE -->
<TABLE CELLPADDING="1" CELLSPACING="2" BORDER="1" WIDTH= "100%"  HEIGHT="22" >
<tr><td bgcolor="#C6E7C6"><center><font size=+2><font color=blue>Program History</fonT>
</fonT></center></td></tr></table>
<!-- PASTE HERE YOUR TARGET'S HISTORY (if any) -->
<br>
None.
<br><br>

<!-- REAL ESSAY  STARTS HERE -->
<TABLE CELLPADDING="1" CELLSPACING="2" BORDER="1" WIDTH= "100%"  HEIGHT="22" >
<tr><td bgcolor="#C6E7C6"><center><font size=+2><font color=blue>Essay</fonT></fonT>
</center></td></tr></table>
<!-- PASTE HERE THE TEXT OF YOUR ESSAY
     THIS IS OF COURSE THE MOST IMPORTANT PART
     PLEASE CHECK THE MARGINS WHEN YOU ARE FINISHED! 
     SHOULD NOT BLAST OPERA'S MARGINS OUT! HAVE A LOOK INSIDE
     YOUR OWN BROWSER WHEN YOU FINISH!  -->

<BR>
Until March 1999 Net@ddress was a good free e-mail provider for a small account 
(with a 5-MB quota):
<UL>
<LI>big enough to remain in business after 6 months (at least hopefully)
<LI>free pop3 access, so anyone with at least half brain could setup his e-mail client 
to never see an advertisement
</UL>

From March they decided to close up the pop3 server (I mean to request a fee for it). 
What could I do? I hate those never-ending advertisements and frames. 
<BR><BR>
Our target: <B>To get our e-mail in a local file in a mbox-like format.</B>
<BR><BR>
<B>Warning:</B> This essay is not for Perl or HTML wizards. The program we will write 
is not optimized. It's just an exercise in both HTML-HTTP and Perl. The wizards should 
take a look at <A HREF="perl_es1.htm#full_src">full source code</A> to see if they find something
useful.
<BR>
<H3>1. Basics - Getting pages</H3>
I suppose you are familiar with Net@ddress. If not, create a test account, send a few e-mails,
read them, print them, feel your target. Looks hard? It is hard using a normal programming
language like C, it's not using good tools: shell scripts with netcat, expect, or Perl.
We have few tasks to accomplish: get pages, login and extract messages from HTML code. 
The hurried ones can go directly to <A HREF="perl_es1.htm#full_src">full source code</A>.
<BR>
How do we get the login page? In C you will have to find the IP address, open a socket,
write some info (what info?) and read the answer. Here is how you do it in Perl:
<CODE><PRE>
# Create the user agent object
$ua = new LWP::UserAgent;
$ua->timeout($timeout);

# Set up a get request. We will use the same get 
# request object for all URLs.
$req_get = new HTTP::Request "GET";

# Send the request and get a response back from the server
to_err "Getting login page $url ... ";

$req_get->url($url);
$response = $ua->request($req_get);
if ( not $response->is_success) {
	to_err "\n\nError\n\n";
	to_err $response->message; 
	exit 1;
}
</CODE></PRE>
You can, of course open sockets in Perl but it's no use. We can use ready-made 
components (or modules). At CPAN you can find a huge collection (more than 600 MB) of Perl 
modules. For our purposes we will use LWP, HTTP::Request::Common, HTML::Entities, 
and HTML::TokeParser. To use a module just say you need it:
<CODE><PRE>
use LWP;
use HTTP::Request::Common;
use HTML::Entities;     # for &amp;lt;
use HTML::TokeParser;
</CODE></PRE>
It's like <CODE>#include &lt;stdio.h&gt;</CODE> in C. Those modules will give us an easy 
way to get pages,  parse them and post responses. 
<BR>

Let's analyze the above code piece by piece:
<CODE><PRE>
# Create the user agent object
$ua = new LWP::UserAgent;
$ua->timeout($timeout);
</CODE></PRE>
Every action (whatever is the protocol: HTTP, FTP, FILE, GOPHER, etc.) is taken through
a <I>user agent</I>. A user agent performs a <I>request</I> and return a <I>response</I>.
Here we create our user agent and set it's timeout to 180 seconds. If timeout expires 
(during processing a request) the user agent generate an error response.
<CODE><PRE>
# Set up a get request. We will use the same get request object for all URLs.
$req_get = new HTTP::Request "GET";
</CODE></PRE>
In HTTP protocol two methods are the most used: <I>GET</I> and <I>POST</I>. GET for 
GETting information and POST for POSTing responses to server. 
<CODE><PRE>
$req_get->url($url);
$response = $ua->request($req_get);
if ( not $response->is_success) {
	to_err "\n\nError\n\n";
	to_err $response->message; 
	exit 1;
}
</CODE></PRE>
In variable <CODE>$url</CODE> we stored (see <A HREF="perl_es1.htm#consts">full source code</A>) 
our target address: <CODE>"http://www.netaddress.com"</CODE>. The  line:
<CODE>
$response = $ua->request($req_get);
</CODE> actually perform the request and return an answer. <CODE>to_err</CODE> it's a 
subroutine which prints a string on STDERR (see <A HREF="perl_es1.htm#subs">full source code</A>).
<BR><BR>
Try for yourself to make program print the source of the page it just fetched.


<H3>2. Logging in - Parsing HTML and POST-ing data</H3>


By checking the source we can see how they verify that our browser supports 
java-script: on form "loginform" they initialize hidden input "java-script" with "none" and
on submit, in function "SubmitLogin" called "onSubmit" set it as appropiate so if your
browser don't support java-script they get "none" and return other page. For learning 
we gonna analyze this page and extract necessary values from "loginform". To parse
a HTML page we need a "TokeParser" object:
<CODE><PRE>
$p = HTML::TokeParser-&gt;new(\$response-&gt;content) || die $!;
</CODE></PRE>
Now get all tokens from HTML page searching for a form named "loginform":
<CODE><PRE>
# Search login form
$found = 0;
while ($token = $p-&gt;get_tag("form")) {
	my $name = $token-&gt;[1]{name} || "-";

	if ($name eq "loginform") {
		$found = 1;
</CODE></PRE>
Get "action" (where to post) and method (which should be POST):
<CODE><PRE>
$action= $token-&gt;[1]{action} || die $!;
$method= $token-&gt;[1]{method} || die $!;
if ( $method ne "POST" ) {
	to_err "\n\nError - Login Form method is not POST ($method)\n\n";
	exit 1;
}
</CODE></PRE>
Now get values for all interesting input elements. Note that for "java-script" we don't
use the supplied value but instead choose a legal values from "SubmitLogin" function.
<CODE><PRE>
$token = $p-&gt;get_tag("input");
($token-&gt;[1]{name} eq "LoginState") || die $token-&gt;[1]{name};
$LoginState = $token-&gt;[1]{value};

$token = $p-&gt;get_tag("input");
($token-&gt;[1]{name} eq "SuccessfulLogin") || die $token-&gt;[1]{name};
$SuccessfulLogin = $token-&gt;[1]{value};

$token = $p-&gt;get_tag("input");
($token-&gt;[1]{name} eq "NewServerName") || die $token-&gt;[1]{name};
$NewServerName = $token-&gt;[1]{value};

$token = $p-&gt;get_tag("input");
($token-&gt;[1]{name} eq "java-script") || die $token-&gt;[1]{name};
$java-script = "JScript1.0";

$token = $p-&gt;get_tag("input");
($token-&gt;[1]{name} eq "DomainID") || die $token-&gt;[1]{name};
$DomainID = $token-&gt;[1]{value};

$token = $p-&gt;get_tag("input");
($token-&gt;[1]{name} eq "NA31site") || die $token-&gt;[1]{name};
$NA31site = $token-&gt;[1]{value};

$token = $p-&gt;get_tag("input");
($token-&gt;[1]{name} eq "NA31port") || die $token-&gt;[1]{name};
$NA31port = $token-&gt;[1]{value};

last;
	}

}

if ($found != 1) {
	to_err "\n\nError - Can't find LoginForm\n\n";
	exit 1;
}

to_err "Ok.\n";
</CODE></PRE>
Now we have all the information needed to construct our response to login form. 
<CODE><PRE>
# Create POST object 
# (this way is more clear than: new HTTP::Request "POST"...)
to_err "Posting login data ... ";

$req_put = POST $url."/".$action, 
		[	LoginState =&gt; $LoginState,
			SuccessfulLogin =&gt; $SuccessfulLogin,
			NewServerName =&gt; $NewServerName,
			java-script =&gt; $java-script,
			DomainID =&gt; $DomainID,
			NA31site =&gt; $NA31site,
			NA31port =&gt; $NA31port,
			UserID =&gt; $user,
			passwd =&gt; $pass,
		];

$response = $ua-&gt;request($req_put);

if ( not $response-&gt;is_success) {
	to_err "\n\nError\n\n";
	to_err $response-&gt;message; 
	exit 1;
}
</CODE></PRE>
Already familiar: construct a request, pass it to our agent, perform request and get 
response. 
<BR><BR>
Probably you noticed that after login you are "<I>redirected</I>" a another
page (BTW with frames). This is the moment where I used Lynx and it's very nice "trace"
option. I save locally a login page and I modified to initialize "java-script" input with
"Jscript1.0". I start Lynx with "trace" from this page and made a succesful login.
The trick is a "Refresh" header tag which redirects us to the correct page.
<BR>
To parse header we need a "HeadParser" :-):
<CODE><PRE>
$p = HTML::HeadParser-&gt;new; 
$p-&gt;parse($response-&gt;content);
if ( not $entry = $p-&gt;header('Refresh') ) {
	to_err "\n\nError - Can't find Refresh in page\n\n";
	exit 1;
}
</CODE></PRE>
Now variable "entry" contains value for tag "Refresh". The protection of Net@ddress
is based on a random number generated on each login (if someone know how they generate
it, please tell me). We can extract this number from value of "Refresh" tag. As you can
see from <A HREF="perl_es1.htm#subs">subroutines</A> having this number we can directly 
access our Inbox. Of course they 
present it in a frame but we don't need the frame :-).  We will see soon what we need
to access individual messages.

<H3>3. Getting messages - Regular expressions</H3>

To access our Inbox we have to extract that number from "Refresh" tag value.
<CODE><PRE>
$entry = substr($entry, 6);
</CODE></PRE>
Discard few characters from "entry" (what characters ?).
<CODE><PRE>
# Now entry is something like 
# http://www.netaddress.com/tpl/Door/?????/Welcome
#
# Inbox folder should be at 
# .../tpl/Mail/????/List?FolderID=-4 and so on
# 

# Bad trick, should use constants
if ($entry =~ m#oor/(.*?)/Wel#) {
	$number=$1;
</CODE></PRE>
All the magic is in that ugly line. To understand it you need to take a break and
read "perlre" or a documentation on "<I>regular expressions</I>". This line can be read
this way: try to mach the string "oor/", followed by any char "." repeated zero or more
times "*?", followed by string "/Wel". I told you to learn about regular expressions :-).
As a side effect of match Perl store the expression in variable "1".
<BR><BR>
Now, getting the Inbox page is piece of cake:
<CODE><PRE>
$inbox = b_inbox ($number);
$req_get-&gt;url($inbox);
$response = $ua-&gt;request($req_get);

if ( not $response-&gt;is_success) {
	to_err "\n\nError\n\n";
	to_err $response-&gt;message;
	exit 0;
}
</CODE></PRE>
Take a look at Inbox page source. Remember our target? <B>To get our e-mail in a local 
file in a mbox-like format.</B> Now I'm expecting you to browse a little and find where
is the best format of messages.
<BR><BR>
Stop reading now and try to solve this.
<BR><BR>
<HR>
<BR><BR>
It's in "PrintPreview" with full headers (of course you didn't forgot about headers).
<BR><BR>
How can we get there? We need message number (which is also the SMTP id). Back to Inbox.
See where are the links to messages?. Where are the "Subject" and "From" fields?. 
I suppose you see we need the values of <CODE>MR[i].Q</CODE> if not, take a closer look.
<CODE><PRE>
# Nice, :-)
@mails = ($response-&gt;content =~ m/^MR\[i\]\.Q='(.*?)';/mg );
</CODE></PRE>
By using "@" we request Perl to give us an array with all values it's find. The regular 
expression "m/^MR\[i\]\.Q='(.*?)';/mg" can be read: considering it a multiline string match
globally "mg", at the beginning of line "^" string "MR[i].Q=", followed by any char "." 
repeated zero or more times "*?", followed by string ";". By using operator "=~" we tell
Perl to give us what it match (for ".*?").

After that it's easy to get our messages. The rest of program is for you to analyze 
and improve. 
<BR><BR>
Can you find a way to fetch one page less ? For those which will answer to this question
I'll provide (if they need) more help with the last part of program.
<BR>
My address is john_smith86(at)usa(dot)com


<H3><A NAME="full_src">4. Full source code</A></H3>

<CODE><PRE>
#
# Net Pop:	Get Net@ddress e-mail
#
#
#	Written by [blue] &lt;john_smith86@usa.net&gt;
#

use strict 'subs';

use LWP;
use HTTP::Request::Common;
use HTML::Entities;     # for &amp;lt;
use HTML::TokeParser;

<A NAME="consts"></A>
# Constants
$url = "http://www.netaddress.com";
$timeout = 180;

$TrashID = "-1";
$InboxID = "-4";


# Subroutines 
sub to_err;	# Print a string to STDERR
sub b_inbox;	# Build Inbox URL
sub b_pprev;	# Build PrintPreview URL
sub b_delete;	# Build Delete URL

# Stollen from lwp-request 
$progname = $0;
$progname =~ s,.*/,,;		# use basename only
$progname =~ s/\.\w*$//;	# strip extension, if any
to_err "\nThis is $progname using libwww-perl-$LWP::VERSION\n\n";

$user="example";
$pass="password";

to_err "Getting mail for $user.\n\n";

# Create the user agent object
$ua = new LWP::UserAgent;
$ua-&gt;timeout($timeout);

# Set up a get request.  We will use the same 
# get request object for all URLs.
$req_get = new HTTP::Request "GET";

# Send the request and get a response back from the server
to_err "Getting login page $url ... ";

$req_get-&gt;url($url);
$response = $ua-&gt;request($req_get);
if ( not $response-&gt;is_success) {
	to_err "\n\nError\n\n";
	to_err $response-&gt;message; 
	exit 1;
}

to_err "Parsing it ... ";

$p = HTML::TokeParser-&gt;new(\$response-&gt;content) || die $!;

# Search login form
$found = 0;
while ($token = $p-&gt;get_tag("form")) {
	my $name = $token-&gt;[1]{name} || "-";

	if ($name eq "loginform") {
		$found = 1;

$action= $token-&gt;[1]{action} || die $!;
$method= $token-&gt;[1]{method} || die $!;
if ( $method ne "POST" ) {
	to_err "\n\nError - Login Form method is not POST ($method)\n\n";
	exit 1;
}

$token = $p-&gt;get_tag("input");
($token-&gt;[1]{name} eq "LoginState") || die $token-&gt;[1]{name};
$LoginState = $token-&gt;[1]{value};

$token = $p-&gt;get_tag("input");
($token-&gt;[1]{name} eq "SuccessfulLogin") || die $token-&gt;[1]{name};
$SuccessfulLogin = $token-&gt;[1]{value};

$token = $p-&gt;get_tag("input");
($token-&gt;[1]{name} eq "NewServerName") || die $token-&gt;[1]{name};
$NewServerName = $token-&gt;[1]{value};

$token = $p-&gt;get_tag("input");
($token-&gt;[1]{name} eq "java-script") || die $token-&gt;[1]{name};
$java-script = "JScript1.0";

$token = $p-&gt;get_tag("input");
($token-&gt;[1]{name} eq "DomainID") || die $token-&gt;[1]{name};
$DomainID = $token-&gt;[1]{value};

$token = $p-&gt;get_tag("input");
($token-&gt;[1]{name} eq "NA31site") || die $token-&gt;[1]{name};
$NA31site = $token-&gt;[1]{value};

$token = $p-&gt;get_tag("input");
($token-&gt;[1]{name} eq "NA31port") || die $token-&gt;[1]{name};
$NA31port = $token-&gt;[1]{value};

last;
	}

}

if ($found != 1) {
	to_err "\n\nError - Can't find LoginForm\n\n";
	exit 1;
}

to_err "Ok.\n";

# Create POST object (this way is more clear 
# than: new HTTP::Request "POST"...)
to_err "Posting login data ... ";

$req_put = POST $url."/".$action, 
		[	LoginState =&gt; $LoginState,
			SuccessfulLogin =&gt; $SuccessfulLogin,
			NewServerName =&gt; $NewServerName,
			java-script =&gt; $java-script,
			DomainID =&gt; $DomainID,
			NA31site =&gt; $NA31site,
			NA31port =&gt; $NA31port,
			UserID =&gt; $user,
			passwd =&gt; $pass,
		];

$response = $ua-&gt;request($req_put);

if ( not $response-&gt;is_success) {
	to_err "\n\nError\n\n";
	to_err $response-&gt;message; 
	exit 1;
}

# Parsing answer to loggin
to_err "Parsing answer ... ";

$p = HTML::HeadParser-&gt;new; 
$p-&gt;parse($response-&gt;content);
if ( not $entry = $p-&gt;header('Refresh') ) {
	to_err "\n\nError - Can't find Refresh in page\n\n";
	exit 1;
}

$entry = substr($entry, 6);
# Now entry is something like 
# http://www.netaddress.com/tpl/Door/?????/Welcome
#
# Inbox folder should be at .../tpl/Mail/????/List?FolderID=-4 and so on
# 

# Bad trick, should use constants
if ($entry =~ m#oor/(.*?)/Wel#) {
	$number=$1;
} else {
	to_err "\n\nError - Bad redirect address $entry\n\n";
	exit 1;
}

to_err "Ok ($number)\n";

to_err "Getting Inbox page ... ";

$inbox = b_inbox ($number);
$req_get-&gt;url($inbox);
$response = $ua-&gt;request($req_get);

if ( not $response-&gt;is_success) {
	to_err "\n\nError\n\n";
	to_err $response-&gt;message;
	exit 0;
}

to_err "Ok.\n";

# Nice, :-)
@mails = ($response-&gt;content =~ m/^MR\[i\]\.Q='(.*?)';/mg );

if ($#mails == -1 ) {
	to_err "\nYou have no mail.\n\n";
	exit 0;
}

to_err "\nYou have ";
to_err $#mails+1;
to_err " messages.\n\n";

foreach $msg (@mails) {
	to_err "Getting message $msg ... ";

	$amsg = b_pprev($number);
	$amsg .= "Q=".$msg.":".$InboxID;
	$amsg .= "&Headers=True";
	$amsg .= "&FolderID=".$InboxID;
	$amsg .= "&Sort=Date";

	$req_get-&gt;url($amsg);
	$response = $ua-&gt;request($req_get);

	if ( not $response-&gt;is_success) {
		to_err "\n\nError\n\n";
		to_err $response-&gt;message; 
		exit 1;
	}

	to_err "Parsing it ... ";

	# Get the body of message (everything is 
        # between &lt;body&gt; and &lt;/body&gt;	
($junk, $body) = ( $response-&gt;content =~ m/&lt;body(.*?)&gt;(.*?)&lt;\/body&gt;/msg );
	
	# HTML spaces -&gt; /dev/null
	$body =~ s/&nbsp;&nbsp;//misg;
#
# Ugly !!!
# match:
#	any string of zero or more spaces and TABS 
#	AND NOT followed by &lt;/tr&gt;
#	AND NOT followd by &lt;br&gt;
#	AND followed by &lt;
#	AND followed by A string of any char EXCEPT &lt;&gt;
#	AND followed by &gt;
#	AND followed by a string of space and TAB
#	AND followed by NEW-LINE
# Remove it (substitute with empty string)
# 
$body =~ s/([ \t]*)(?!&lt;\/tr&gt;)(?!&lt;br&gt;)&lt;([^&lt;&gt;]*?)&gt;([ \t]*)(\n?)//misg;

	# Remove empty lines + -&gt; one or more !
	$body =~ s/([ \t]*)(\n)+//msg;

	# Replace &lt;BR&gt; and &lt;/TR&gt; with NL
	$body =~ s/[ \t]*&lt;br&gt;/\n/misg;
	$body =~ s/[ \t]*&lt;\/tr&gt;/\n/misg;

	decode_entities($body);

	print "$body\n\n";

	to_err "Ok.\n";
	to_err "Deleting message $msg ... ";
	
	# Create POST object (this way is more clear than: new HTTP::Request "POST"...)
	$req_put = POST b_delete($number), 
		[	Q =&gt; $msg,
			N =&gt; "",
			F =&gt; $TrashID,
			FolderID =&gt; $InboxID,
			Sort =&gt; "Date",
		];


	$response = $ua-&gt;request($req_put);

	if ( not $response-&gt;is_success) {
		to_err "\n\nError\n\n";
		to_err $response-&gt;message; 
		exit 1;
	}

	to_err "Ok.\n";

}

<A NAME="subs"></A>
# ----- Subroutines

# Print a string to STDERR
sub to_err {
        die "to_err: Need an argument !" unless $_[0];

	print STDERR $_[0];
}

#Build Inbox URL
sub b_inbox {
        die "b_inbox: Need an argument !" unless $_[0];
	
	return $url."/tpl/Mail/".$_[0]."/List?FolderID=-4";

}

# Build PrintPreview URL
sub b_pprev {
        die "b_pprev: Need an argument !" unless $_[0];
	
	return $url."/tpl/Message/".$_[0]."/PrintPreview?";

}

# Build Delete URL
sub b_delete {
        die "b_delete: Need an argument !" unless $_[0];
	
	return $url."/tpl/Message/".$_[0]."/Move";


}
</CODE></PRE>

<br><br>

<!-- FINAL NOTES STARTS HERE -->
<TABLE CELLPADDING="1" CELLSPACING="2" BORDER="1" WIDTH= "100%"  HEIGHT="22" >
<tr><td bgcolor="#C6E7C6"><center><font size=+2><font color=blue>Final Notes</fonT>
</fonT></center></td></tr></table>

You see a small example of how to use Perl to build you own tools. Perl is not easy to 
learn (especially regular expressions) but very powerful.
<BR><BR>
You can read carefully the "Subscriber Agreement". They don't mention that you are bound
to see those advertisements, so you shouldn't see them.

<!-- PASTE HERE YOUR FINAL NOTES (if any) -->
<br><br>

<!-- OB DUH STARTS HERE -->
<TABLE CELLPADDING="1" CELLSPACING="2" BORDER="1" WIDTH= "100%"  HEIGHT="22" >
<tr><td bgcolor="#C6E7C6"><center><font size=+2><font color=blue>Ob Duh</fonT></fonT>
</center></td></tr></table><center><i>I wont even bother explaining you 
   that you should BUILD your own bots and tools to avoid (or destroy :-) 
all those commercial banner-clicking 
infernos you are compelled to slurp. I will bother telling you, though, that 
you should send a copy of those same bots and tools to good old fravia+<br>Building 
our weapons on each other's shoulders we'll transform the next Millennium in an 
advertisement-free 
aera!</i></center>

<!-- WAY OUT STARTS HERE -->

<hr>
</font>
<!-- internet searching strategies and hints content, end -->
<center><a href="antiadve.htm"><img SRC="images/antiadv.gif" ALT="antiadv" BORDER=0 
height=43 width=114 align=BOTTOM></a><br><br>
<!-- how to search the web, by fravia+, signet begin -->
<table><tR><td width="300" height="2" bgcolor="#993300"></tD></tR></table>
<IMG align=center valign=center width=500 height=4
SRC="images/dot_peri.gif"><bR><IMG align=center valign=center width=5
height=40 SRC="images/dot_peri.gif">
(c) 2000: <font color=blue>[</font><a
href="info.htm">fravia+</a><font color=blue><font
color=blue>]</fonT></font>, all rights reserved
<IMG align=center valign=center width=5 height=40
SRC="images/dot_peri.gif"><br><!-- how to search the web, by fravia+,
signet end -->


<!-- begin da closing bit, duh -->


<!-- begin da closing bit, duh -->
</CENTER>
</body>
</HTML>
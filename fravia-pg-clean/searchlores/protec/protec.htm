<html>
<head>
<title>protec.htm: HOW TO PROTECT BETTER</title> 
<!-- web searching lore: pagename end -->
<meta http-equiv="Content-Type"		content="text/html; charset=iso-8859-1">
<meta http-equiv="Content-Style-Type"	content="text/css">
<meta http-equiv="Content-Script-Type"	content="text/javascript">
<meta name="description"	content="This site teaches basic and advanced search techniques for people ]ested in finding any kind of information on the web. Here are informations, documents, links, etc. related to web-searching">
<meta name="keywords"		content="cheat machine crack. Crack crackz warez, hack serials registration code keygen the
elite that 3l33t crack for cheat machine the cheatmachine crack with free key . elite
code, underground Where can I get a free registration code? download who patcher fake
keygen nfo generate key registration code ? regcode, get your cracks here it defeat copy
protection warez why.grouptop site my reg key warez how do I crack search, warez crack
sitestop 50 mp3 MP3 bleem pc playstation mod chip, How do I search the web?, fravia+">
<meta name="author"		content="fravia+">
<meta name="copyright"		content="Copyright(c) 1952-2032 fravia+">

<STYLE type="text/css"> A:link { color: #02F } A:visited  { color: #808 } A:hover { color: purple; background: #AFB } </STYLE></head>
<BODY bgcolor="#CCCCCC" TEXT=#001010 LINK=#0000FF ALINK=#00FF00 VLINK=#3366CC>
<table border="0"><tr><td colspan=3>
<center><font size=+3>FRAVIA'S "HOW TO PROTECT BETTER"<bR></fonT><font size=+2><i>A 
good protection is NOT an impossible dream</i>!</font>
</center></td></tR>
<tR><td><center><a href="../others.htm"><IMG SRC="../images/protec_big1.jpg" ALT="Ivan Bilibin: "a good protection is not a dream" 
ALIGN=CENTER WIDTH=534 HEIGHT=320 BORDER=0 VSPACE=0
 HSPACE=0></a><br>
<!-- --------------------------|||||------------->
Last updated: <font color=blue>May</font> 2005</center>
<!-- --------------------------^^^^^------------->
 </td><td bgcolor="#00E900">&nbsp;</tD>
<td align="center"><font size=+2>
<font color=blue>How to (try to) protect software effectively</fonT></font>
<table><tr><tD><center><font size=+1>
<font color=blue>[</font><a href="protec.htm#anchorintro">as introduction...</a><font color=blue>]</font><br>advices<br>
<font color=blue>[</font><a href="protec.htm#anchoradm">Mark's</a><font color=blue>]</font><br> 
<font color=blue>[</font><a href="protec.htm#anchoradt">Tidbit's</a><font color=blue>]</font><br>
<font color=blue>[</font><a href="stonetips.htm">Stone's</a><font color=blue>]</font>
<font color=blue>[</font><a href="mike_can.htm">Mike's</a><font color=blue>]</font>
<br><font color=blue>[</font><a href="protec.htm#anchoradmo">More tips</a><font color=blue>]</font><br>
<font color=blue>[</font><a href="protec.htm#anchorshr">To shrink?</a><font color=blue>]</font><br>

<font color=blue>[</font><a href="htp_essa1.htm" tppabs="http://fravia.net/htp_essa1.htm">essays</a><font color=blue>]</font>&nbsp;<font color=blue>[</font><a href="protec.htm#anchortric">tricks</a><font color=blue>]</font><bR>
<font color=blue>[</font><a href="protec.htm#anchorlin">links</a><font color=blue>]</font>&nbsp;
<font color=blue>[</font><a href="protec.htm#oldies">Oldies</a><font color=blue>]</font></fonT></center></tD></tr></table></center></tD>
</tr>
</table>
<a name="anchorintro"></a>
<hr>
<center><Font size=+2><font color=gray>Software Protection, 
an impossible dream?</fonT></fonT><br><bR><font size=+1>Jump 
+fravia's Intro and go directly to <font color=blue>[</font><a href="protec.htm#anchoradm">All the 
advices you may need</a><font color=blue>]</font>
<hr>INTRODUCTION: The never never ending <u>dongles</u> discussion...<br></font>

</center><br>CONTRA: fravia+ on dongles<br>
<br><i>I have recently (26 January 2001) received this mail...</i><pre>
         I am looking for information about hardware locks, 
         how effective they are, and if they are reliable 
         enough to safeguard new software.
         Your expertise would be appreciated...</pre> 
<i>
What you call 'hardware locks' are more commonly known as 'dongles' in the scene, 
I didn't follow the most recent developments, but as far as I know:
<br><br>
They still are expensive, cumbersome for users and relatively easy 
to circumvent unless correctly programmed (newbies can crack 
and disable all sort of simple checks for the existence of the dongle).
<br><br>
Even when correctly implemented through your software, dongles can 
be reversed in a couple of days  -at most- and they <u>will</u> be reversed 
if the program is worth it (this on the other hand being a bigger and bigger 
if nowadays&nbsp;:-)
<br><br>
If I were you I would rather go for the usual serialnumber approach based on the 
harddisk-number checking. You can get the harddisknumber with
 </i>GetVolumeInformationA(<a href="protec.htm#exemp">*</a>)<i>, that you should <u>not</u> 
 call but REPRODUCE with your own 
 assembly code, else it will be easily breakpointed, duh), 
and combine such routines with one of the many unobtrusive "phoning home" 
approaches.<br> <br>
This will give you a light protection... thus few zombies will deprotect your soft 
(if everything has been implemented in assembly, that is: if you use visual basic any kid
will be able to 'smartcheck' it) and when crackers will crack it you will, at least, know how many people are really using your software around the planet and, grossomodo, where. 
Pack everything with a good packer after having thrown in a small assembly written 
softice-checking routine which will slightly change the serial number needed 
<u>only if softice is present and running on the machine</u> (and which will abstain 
from doing ANYTHING else), and you'll have what in my opinion amounts to be 
the "state of the art non-dongled protection" that your knowledge can buy... still crackbar of course&nbsp;:-)
<br><br>
Good luck<br></i>
fravia+<br><hr width=44%><br>
PRO: Mike Stay on dongles
<br><br>
The only way to prevent someone from reverse-engineering your code is
not to give it to them (see: <a href="protec.htm#tid18">Tidbit's #18</a>).  On the other hand, you can't
expect people to pay for functionality they don't get (unless you're
Microsoft), so your customers need to be able to execute the code. <br>
One way: a dongle that executes code, like Dallas semiconductor's Java
iButton.  Put a small but vital piece of code there; make it complex
enough so that reversers can't just figure out what it does and patch
the exe.  Short of differential power analysis, reversers are pretty
much screwed. Another way: put the code on your server and force the client to
authenticate itself; a simple challenge / response system can work
fine.<br>But the secret that allows authentication can be shared among pirates.<br>
You can watch (i.e. write a program to watch) to see if the IP address
of the client changes a lot and disable it if you think it's being
abused.  For a perfect system, a time-based cryptographically secure
pseudo-random number generator in a dongle (a la RSA SecurID) is
synchronized with your server.  This can get expensive, but it can't be
broken without hacking into your server.<br><br>
Mike Stay<br>
Programmer / Crypto guy, <a href="http://www.accessdata.com">AccessData Corp</a>.
<br>
<a name="anchoradm"></a>
<center><br><br><IMG SRC="../images/bulletr.gif" ALT="red" ALIGN=CENTER WIDTH=600
HEIGHT=7 BORDER=0 VSPACE=0 HSPACE=0><bR>
<br></center><IMG SRC="../images/protec.gif"  ALT="protec" 
ALIGN=LEFT WIDTH=114 HEIGHT=43 BORDER=0 VSPACE=0 HSPACE=0> 
<font color=blue> <font size=+2> Mark's famous 14 protector's commandments</font></fonT>
<ul>
<li>1 Never use meaningful file or procedure names such as 
  IsValidSerialNum (duh.) If you do use functions for 
  checking purposes, place at least some required code 
  that your program really needs, in such a function. 
  When the cracker disables the function, the program 
  will produce incorrect results.
</li><lI>2 Don't warn the user right after a violation is made.  
  Wait later, maybe until the next day or two (crackers hate that).
</li><lI>3 Use checksums in DLL's and in the EXE.  Have them check each other.  
  Not perfect but it just makes it harder to crack.
</li><lI>4 Pause a second or two after a password entry to make brute 
  force cracking unfeasible.  Simple to do, but rarely done.
</li><lI>5 Self-heal your software.  You know, error correction like modems 
  and hard drives use.  The technology has been around for years, 
  and no one uses it on their software?  The best thing about this 
  is that if the cracker used a decompiler, they may be looking at 
  a listing that is no longer valid.
</li><lI>6 Patch your own software.  Change your code to call different 
  validation routines each time.  Beat us at our own game.
</li><lI>7 Store serial numbers in unlikely places, like as a property 
  of a database field.
</li><lI>8 Store serial numbers in several places
</li><lI>9 Don't rely on the system date.  Get the date of  several files, 
  like SYSTEM.DAT, SYSTEM,DA0 and BOOTLOG.TXT and compare them to 
  the system date.  Require that the time be greater than the last 
  run.
</li><lI>A Don't use literal strings that tell the user that their time is 
  expired.  These are the first things to look for.  Build strings 
  dynamically or use encryption.
</li><lI>B Flood the cracker with bogus calls and hard-coded strings.  Decoys 
  are fun.
</li><lI>C Don't use a validation function.  Every time you validate the user, 
  write your validation code inline with the current process.  That 
  just makes more cracking for the cracker.
</li><lI>D When using hard-coded keys or passwords, make them look like program 
  code or function calls (i.e., "73AF" or "GetWindowText").  This 
  actually works very well and confuses some decompilers.
</li><lI>E Finally, never reveal your best protection secrets :-)
</LI></ul>
<br>
<a name="anchoradt"></a>
<hR><IMG SRC="../images/protec.gif"  ALT="protec" 
ALIGN=LEFT WIDTH=114 HEIGHT=43 BORDER=0 VSPACE=0 HSPACE=0> 
<font color=blue> <font size=+2> Tidbit's 'common sense' rules</font></fonT>
<br><ul>
<li>1. No nagscreens. Making enemies among your customers is very stupid, indeed.
</li><lI>2. Create important menus and dialog boxes dynamically, whether in something
like turbo-vision, xforms or m$windoze. Use your own format of rcdata like borland
did in delphi if you don't want to write too much code.
</li><lI>3. If your program doesn't save data in "crapware" edition, don't include a "grayed"
menu item. No saving means no saving. That's it.
</li><lI>4. The only way to tell user that he is unregistered should be in the "about" dialog.
The latter should also be created dynamically.
</li><lI>5. Avoid using any kind of string resources like "this crap is unregistered, blah blah"
</li><lI>6. Link statically unless your program is a complex one (at least of m$word 2.0
complexity)
</li><lI>7. Don't loose time on writing anything that will kill disassemblers or debuggers.
Take my word on it - doing it is worthless, people who made them or HCU'ers :-)
will soon find the way around, so shift your interest to more important stuff.
</li><lI>8. Use your language of choice fully. Even if it's visual basic, learn it thoroughly first.
Using some advanced constructs it is possible to make debugging a nightmare.
</li><lI>9. Use run time library fully when writing the beta versions, in final release rewrite
some functions at least to make crackers life harder.
</li><lI>9a) Example: many ocx'es for vbasic take PLENTY of space, and they are really
easy to hook to. Use only ones which you need, usually much of ocx crap can be
rewritten to use plain windows api.</li>
<lI>10. Take SOME time to THINK about protecting your software. Is it worth the
protection? Wouldn't it be better to IMPROVE YOUR SOFTWARE, rather than
improving protections?
</li><lI>11. Try to embed at least part of the protection inside the data manipulation.
Data structures can take ages to understand basing only on disassembly listing,
they also are more error-prone for cracker. Crackers usually take notes on loose
sheets of paper, and not everyone reads his own handwriting 100% accurately.
</li><lI>12. A protection that mangles data is a good one usually.
</li><lI>12a) Example: Got a charting program. The crapware shouldn't print. Disabling
printing and later on enabling it basing on some registration# is the most often
committed suicide. Let your thingo print. When creating data structures for
printing, mangle them in some way. Unmangle them just before printing, using
reg# or something other for that purpose. Even more, make this mangling subtle.
Assume that you've got a pie chart to print. Don't alter anything, but add some
not too big random numbers to values of data series - this is mangling then.
The chart will look "not that bad", but will be otherwise unuseable (if the changes
are random and on the order of 20%, for example). Finding such protection, if
its connection with reg# is not self-evident can take much time. One has to delve
inside your data structures and find that dreaded mangling and unmangling code. Not
too easy, especially if you program high level, not in asm.
</li><lI>13. When mangling data, use some tricks so that it is not self-evident where that
reg# comes from into unmangling code.
</li><lI>13a) Example: I did it for a dos platform once. The reg# (in a "go/no-go" protection)
was specified as a command line argument. The command line parser was clean and
it was the only place where command line was ever referenced. In some other place
the "irrevelant" code  was using a "bad" version of borland pascal move routine from 
rtl (move copies a range of data from here to there). The routine in rtl was altered 
to copy a few bytes more and to wrap around the segment boundary. The "irrevelant" code
called copy with parameters set so that it would copy some useless crap together with
command line somewhere else, and that "somewhere" was left unused for some time. It was
evaluated in the wholly other part of program. Athough setting bpx on memory range would
find that, it was not THAT evident that one should place the "enable#" on command line
(it was nowhere mentioned since I needed to protect from my coworkers only).
</li><lI>14. Be economically inclined. Calculate whether you need to write your "to be protected"
program at all. Isn't there (albeit big) a commercial, widely available package that
does the same thing? If you need that tiny program for yourself only, in 99% of cases
it's cheaper to use existing package that supports scritping (to tailor it to your needs).
If you want to sell it, check your market. The problem of protecting software vanishes
if no one will use your software. Don't overestimate your work's "importance to the world".
Search the net. There's nothing like you want to do? Search more, then. Start work only
when you're sure there's need.
</li><lI>15. Always explore your language of choice on the level proposed (or, more often these
times, pushed) by the language developers. If you're real programmer that doesn't want
his "hello world" app to be 2megs+ big, shift down to the api level asap - ie. after
exploring all the nice "visualties" the commercial types might be pushing you to use.
</li><lI>15a) Example: This pertains mostly to things like borland c++, delphi and m$ vc++ -
write your app using the existing user interface crap (foundation classes etc). When
the innards are debugged (hah, they never are, but if you at least don't find any bugs
in the first 20 minutes of post-build testing), rewrite your user interface to use
windows api directly. Do it cleverly, think first, think a lot, and you'll usually get
an app that is at most 1/4 of the original size, and that works much faster. Do you
believe that corel draw 3 was written using nearly pure api? Such a HUGE app? - you
say it's impossible. No, it quite is, ever more in the 32bit world when you don't need
to spend so much time moving data around the 16bit segment boundary (corel 3.0 was for
windows 3.x - it was 16 bit).
</li><lI>16. What does p.15 have to do with protections, you think. Oh well, it does have much.
Since your code doesn't use the "prepackaged" stuff, it's more personal, more custom.
Since each programmer's style of programming is different, it take more time for a
potential cracker to find out what's going inside your app. Alas, all this is useless
if cracker doesn't have to know the innards to deprotect. So always protect in a way
that is tied in MANY PLACES to the innards (data structures etc).
</li><lI>17. A monolithic app that doesn't reference to much more than kernel or device drivers
is usually harder to crack. There are less dependencies to get from watching the .exe
and .dll's with quickview for example. Try to export only the callbacks needed by
windoze for example. Check what goes to the outside world. Try to include no or little
details of registration procedure. Your code should give as little information in "clear
text" to the cracker as possible.
</li><a name="tid18"></a><lI>18. For god's sake, don't give away the working code! Try to provide users with:
<br>- The crapware version, that DOESN'T have the "missing features" compiled in. This thing
should also have no nag screens nor "enter reg# here" suff - it's obvious, since it's
the CRAPWARE ONLY.
<br>- The full version, that HAS the full functionality compiled in but that also requires
user to enter the reg# once somewhere. This version should be only given away to those
that have paid. At least there is no way to get the thing to crack from your site, since
you only expose the crapware for lamers. Alas, your "full" version, maybe even cracked,
will be to be found shortly on warez sites, but not everyone knows where to search,
so you at least can be proud that your app has been stolen by "the enlightened" :-)
</li><lI>19. As has been said many times: don't overuse the "registered", "unregistered",
"registration code", etc. words - both in clear text and in encrypted form. If possible,
invent some clever algorith to generate these on the fly basing on some variables,
definitely don't use the "bool Is_Registered" flag anywhere! 
</li><lI>19a) Notes: It would be quite nice if the program will be having some sample (bad?) 
reg# stored inside in some place(s). The user, after entering the registration#, should
have no IMMEDIATE indication of any kind that the software is registered now. THis
indication shouldn't also be deferred using timer, like in unix login. It's childish
easy to find the "sleep x" code. Each function, like save, print, etc. that depends
on registration, should check the reg# by itself, and it should do it in such way
that user nor cracker doesn't see that something is going wrong or good. As said before:
no disabled stuff. If saving is disabled, either don't provide it at all, or make 
the unregistered save work just like real one, just that data isn't written to disk
or is written badly. Consider such scheme: user isn't presented with any "this funct
disabled" box, the save works ok (save dialog opens, save completed "%" bar scrolls
as usually), but you may for example lseek back to the beginning of file after writing
each record if the user isn't reg#. This approach is hard to crack since such attempt
requires to delve DEEP into the program's internals and to find what is going bad
and where. People also think sometimes that their version is simply damaged and throw
their program away, whereas that dreaded save might work ok when registered.
</li><lI>19b) Notes: CLEARLY INDICATE facts mentioned in 19a), like that:
<<"<font color=purple>Reminder: This program, when not registered, won't save nor print any data.
These two functions will operate ONLY when the CORRECT registration number is
entered in the registration dialog box.
Warning: we restate that save and print options WON'T WORK until the CORRECT
registration number is specified. All other features are unaffected in the
unregistered version.<br>
Note: You cannot verify that correct registration number has been entered.
Program doesn't display any warinings that you've entered invalid number.
You know that it is ok when save and printing works, else please retype the
registration number and try again."</fonT>>>
This will indicate:<br>
a) to the user that he definitely WILL enable the program when the CORRECT number
has been entered,<br>
b) to the hacker that it is going to be a tough job since the registration #
checker sits somewhere else.<br>
</li><lI>19c) Implementation notes: Move your reg# to the checker routine in an unsuspicious way. 
If you can, don't use the "existing" textbox and gettexta, implement the reg# 
entering routine by hand, it would be quite wise even to refrain from using the 
existing text rendering procedures and render the number on-screen as it is 
entered using your own renderer. You can edit your own font resource or use 
some preexisting font, then just encode it in some way so that it will be 
unreadable by resource workshops, even better include it in the source as 
static constants. Although it is still easy to find where the "drawbitmap" 
equivalent was used to paint the reg#, it is definitely harder to understand 
the whole underlying routine, especially noticing where does that 
reg# go. Using a multi-layered approach here is the most feasible one:
<br>- dynamically create accelerator keys in your 'register me' dialog box, these
accells should be for keys used in reg# entry (0-9,a-z for example)
<br>- each accell should call different routine, if feasible (makes breakpointing tougher)
<br>- each routine should store the flag that given char was entered somewhere else,
it would be nice if each keypress would modify some global variable, in some way
that is decodeable for you, but not to the cracker (at first glance)
<br>- then there should be some kind of 'monitoring' routine that acts accordingly,
paining the characters on the dialog box and taking actions upon backspace and enter,
for example
<br>- yet another routine should collect all entered characters and create a reg# and store
it in some untrivial place. using a .vxd here to manipulate the virtual memory to make
some 'backup' copies in a not-easily-debuggeable way is a nice idea. a .vxd can work
like a tiny embedded debugger, bpxing on the place where that reg# goes. it can then copy
it to some quite other place, all that happening in the background and not to be noticed
easily. the cracker will of course (at the first try, at least) try to check where this
location is accessed. since it is accessed nowhere, he will scream: how the hell does this
app know that the reg# has been entered, if it even does not access it? oh well, just
a tiny .vxd or even a background thread has copied it somewhere else. they'll get at
it later, but at first it can stir crackers minds, though.
</li><lI>20. Notes on registration numbers:
<br>- balance between security, feasiblity, programmability and end-user headaches
<br>- too long, non-alphanumeric reg#'s tend to be continuously entered badly. at least
provide a "non-persistent" reg# entry field so that user will rewrite the reg# each
time, possibly correctly at last. many people will just "glance-compare" the entered
reg# and the one (possibly) emailed to them, arriving at the final thought that they
did enter it correctly, whereas the font is too small or they are too tired to notice
that this '1' and 'l' have been interchanged (in a reg# like 'l83jjd_0)pH1lTe' )
<bR>- refrain from any user feedback. the reg# entry box should accept strings of any
length, without any validation. don't give crackers the knowledge about reg#.
sometimes knowing that it's 10 chars long or that is contains only uppercase alphabet
helps, so don't help them
<br>- the reg# verification scheme (I'm pretty sorry about it, but it just is like that)
needs to take into account the number of prospective users, and thus you oughta do some
"market analysis"
<br>- if your reg# is 10 numbers long, there are 10^10 possible reg#'s. but since your app
might find let's say only 10^4 (10'000) users, you should invent an algorithm that
assigns each one of 10^4 users one of 10^10 reg#'s, and does it somewhat uniformly. This
prevents people and programs (some .vxd based "macro" players, like the one presented
some time ago in DDJ, for example) to be used for brute force approach. If there are
only 10^4 users and you allow 10^9 "valid" reg#s out of 10^10, on average each 10th 
reg# tried brute-force will be valid, whereas on the case of 10^4 prospective users, that
many valid reg#'s and space of 10^10 reg#s, on average only each 10^6th reg# tried brute
force will be valid. Ever calculated how much time it would take to brute-force search
10^6 numbers, even using a fast machine and extremenly fast macro player (keystroke
generator simulating reg# entry and checking for results)?
<br>- the assignment operator that assigns user# to reg# shouldn't be trivial, and it's 
implementation should be done in asm by someone experienced both in maths (topology
known by +ORC helps here, also :-) and asm. check your operator. create graphs of
how it works. understand your own work, especially its drawbacks and vulnerabilities
<br>- be inventive. don't use anything that seems simple, quick and effective. unless you've
come with something like Einstein's relativity theory, your approach is yes, simple,
yes, quick, but no, not effective, and yes, easy to crack. I'm sorry but we aren't
geniuses and developing a good protection scheme takes time, it took time myself, and
still takes although i'm creating protections for fun since 5 years or so. It will
definitely take some time you, dear reader, and don't believe your self-confidence.
Protections written by self-confident and unexperienced prgrmrs end up in the 
"most
stupid protection" page of +fravia. a nice and exposed place, and with what a
neighboorhood, but a protection ending there is still the "most stupid". not a nice
definition of your work, huh? :-]'
</li><lI>21. Play same game twice. It helps. If you invent some nice and hard to crack memory
move-around scheme to protect reg# inside your data space, do the same to parts of your
data, even better using the same routine just with other parameters. Crackers are
lived up to the fact that protection algorithms are always used for protections only.
If integrity of your data will rely, at least partly, on proper working of your
protection code, crackers get a tough work to do. it's called functional verification
of the "okayness" of protection code. you don't checksum nor crc it, but simply call
it "from the other place" and let it process the protection-unrelated data. if it
will process this data ok, then cracker mustn't have altered it. this places end on
easy cracks like "change that jump here and that cmp there to nops"..
</li><lI>22. Strainer to you: does lotus 1-2-3 for dos "diskette" protection (it let you install
it up to 3 times without "zapping" it from hd first) work still in win95? if yes, why? 
if not, why? analyze the code, I've learnt MUCH from it. it's only dos code, it's
probably 100 times cracked already, but there are some niceties to learn from it.
not a very good protection scheme, has many holes in it, but remember what +ORC said:
a cracker well educated in historical code is nearly always a perfect one :-)))
(ok, ok, i know, there's nothing perfect aside from moskovskaya in this bad world, but,
can't we joke at times ? 8-0=)
<bR><br>
cheerz,<br>
tibit</li></ul>

<br>
<a name="anchoradmo"></a>
<hR><IMG SRC="../images/protec.gif"  ALT="protec" 
ALIGN=LEFT WIDTH=114 HEIGHT=43 BORDER=0 VSPACE=0 HSPACE=0> 
<font color=blue> <font size=+2> More tips you might take into consideration</font></fonT>
 

<br><ul><li>
Use a serial which is several KB long of arithmetical transforms, to drive
anyone trying to crack it insane. This makes a keygenerator almost
impossible - Also, brute force attacks are blocked very efficiently.
</li><lI>
Caution with the Runtime libary! Use it fully when writing the beta versions, in
the final release rewrite some functions at least to make crackers life harder.
</li><lI>
Mangle data. Protection that mangles data is usually a good one.
Example: Imagine a charting program .. e.g., just disabling printing and later
on enabling it basing on some registration# is the most often committed
suicide. Let your thingo print. When creating data structures for printing,
mangle them in some way. Unmangle them just before printing, using reg# or
something other for that purpose. Even more, make this mangling subtle.
Assume that you've got a pie chart to print. Don't alter anything, but add
some not too big random numbers to values of data series - this is mangling
then. The chart will look "not that bad", but will be otherwise unuseable (if the
changes are random and on the order of 20%, for example). Finding such
protection, if its connection with reg# is not self-evident can take much time.
One has to delve inside your data structures and find that dreaded mangling
and unmangling code.
</li><lI>
Traps. Do a CRC check on your EXE. If it is modified then don't show the typical error
message, but wait a day and then notify the user using some cryptic error
code. When (and if) they contact you with the error code, you know that it is due to
the crack. Be aware: such traps could also be activated due to virus infection
or incorrect downloads. Don't blame a potential customer for software piracy. 
</li><lI>
The rcr/rcl trick
If a rcr/rcl is performed on a value, it becomes much more of a pain to crack -
you can't reverse it with by negating it's effects without knowing what the
value of the carry flag was before the original operation. If the carry flag is
created as a result of some other pain in the neck operation, you are probably
onto a winner. 
</li><lI>
Stick conditional jumps in. Everywhere.
Conditional jumps are not fun to reverse engineer. No loops, but jumps which
conditionally bypass/include portions of your wonderful key manipulation
code. There is no easy inverse operation to be performed here. 
</li><lI>
Use portions of the code as magic number tables.
(preferably critical sections). You have no idea how annoying this can be, if
you're like most crackers and like to change things around using softice (a
popular cracking tool). 
</li><lI>
Play with the cracker's mind.
This one is fun :-) Stick series of nops in, as though you were doing
self-modifying code (oh my god! what the heck! nops? Aha! Self-modifying
code! Idiot spends next three years trying to find the code that should be
there.). Pepper the code with junk instructions. Cut the code up into little
pieces and put them all over the executable, with (preferably conditional)
jumps between them. - Anything which you would find a pain in the neck. 
</li><lI>
Detect SoftIce. Early.
Now crash the computer. You can crash a pentium or a pentium with MMX
even without a vxd by the opcode: F0 0F C7 C8 (illegal form of cmpxchg8b
instruction with lock prefix). Beyond that, we have to resort to the tried and
true methods. Using a vxd, take the CPU out of protected mode. Windows
doesn't like that. Wonder why?
<lI></ul>


<a name="anchorshr"></a>
<hr>

<IMG SRC="../images/protec.gif"  ALT="protec" 
ALIGN=LEFT WIDTH=114 HEIGHT=43 BORDER=0 VSPACE=0 HSPACE=0>

<H2><font color=gray><center>Software Protection, 
an impossible dream?</fonT><bR>The Shrinkers discussion</H2></center>

On <font color=blue>[</font><a href="http://inner-smile.com/nocrack.htm">Richard Fellner</a><font color=blue>]</font>'s page I found this snippet:
<pre>Don't rely on "EXE-packers". For almost any tool which compresses EXE files
(Shrinker, WWPack32, NeoLite - to list the most popular ones) there's an
uncompressor around, so compressors capable for software-protection
should at least support configurable encryption. Unpackers for the above (and
other) tools are not very wide-spreaded, however, don't rely on them as your
program's one and only "protection"!</pre>
Now the question is: is this true?
<br><br>
A shrinker, like the one from <a href="http://www.blinkinc.com/" tppabs="http://www.blinkinc.com/">Blinkinc</a> should 
be seen as a 'first line of defense' for a protector. The application will be uncompressed 
when it is loaded and cannot therefore be decompiled from disk. This makes the possibility 
to mess with it  
a little more complicated for the cracker, especially if, after having compressed the 
application with Shrinker or with WWpack32 you checksum (twice) the compressed EXE.
<br><br>
The standard binary post-processors seem at the moment to be:<bR>
<a href="http://www.blinkinc.com/" tppabs="http://www.blinkinc.com/">Shrinker</a><br>
<a href="http://www.previewsystems.com/" tppabs="http://www.previewsystems.com/">VBox</a><br>
and WWrap32<br>
And for these shrinker there are corresponding unshrinkers in the scene... where are they?
<hr ALIGN="center" width=44%>
Well, a first good tool (yet not for beginners) is 
<a href="http://fravia.net/zipped/ucfpd114.zip" tppabs="http://fravia.net/zipped/ucfpd114.zip">procdump</a> a very good unpacker by Riz+la, Stone and 
G-rom (btw: 
in the unpack.txt companion file you'll find VERY USEFUL information about the 
most common commercial' packers). I'm presenting here version 1.1, build 4 from 11 October 
1998. Visit Stone's page to fetch more recent versions.

<a name="anchorlin"></a>
<hr>

<IMG SRC="../images/protec.gif"  ALT="protec" 
ALIGN=LEFT WIDTH=114 HEIGHT=43 BORDER=0 VSPACE=0 HSPACE=0>

<H2><font color=gray><center>Software Protection, 
an impossible dream?</fonT><bR>Links</H2></center>

<center><br><br><IMG SRC="../images/bulletr.gif" ALT="red" ALIGN=CENTER WIDTH=600
HEIGHT=7 BORDER=0 VSPACE=0 HSPACE=0><bR>
<br></center>
<font color=blue><font size=+2>Anti-Cracking sites</font></fonT>

<bR><br>
 'Adam Smith' site: 
<IMG SRC="../images/bulletr.gif" ALIGN=TOP WIDTH=13 HEIGHT=13 BORDER=0 VSPACE=0
HSPACE=0><a href="http://www.viratech.com/sharenc.htm">http://www.viratech.com/sharenc.htm</a>
<br>Brilliant and original ideas (leave a bait_variable, say "<font color=red>Is_registered</font>" evidently positionated but 
always FALSE (and unused) 
in your code ~ check somewhere else if it has been tampered with ~ ahah! a cracker! punish him :-)

<bR><br>
 Vitas Ramanchauskas' site: 
<IMG SRC="../images/bulletr.gif" ALIGN=TOP WIDTH=13 HEIGHT=13 BORDER=0 VSPACE=0
HSPACE=0><a href="http://www.soft4you.com/vitas/antihack.htm" tppabs="http://www.soft4you.com/vitas/antihack.htm">http://www.soft4you.com/vitas/antihack.htm</a>
<br>Some interesting techniques and original ideas
<br><br>Richard Fellner's anti-crack tips 
<IMG SRC="../images/bulletr.gif" ALIGN=TOP WIDTH=13 HEIGHT=13 BORDER=0 VSPACE=0
HSPACE=0><font color=blue>[</font><a href="http://inner-smile.com/nocrack.htm">http://inner-smile.com/nocrack.htm</a><font color=blue>]</font> 
<br>(a part of them has been taken from my site :-)
<br><br>Rob Beckers' How to Battle Warez: 
<IMG SRC="../images/bulletr.gif" ALIGN=TOP WIDTH=13 HEIGHT=13 BORDER=0 VSPACE=0
HSPACE=0><a href="http://www.cat-soft.com/warez.htm">http://www.cat-soft.com/warez.htm</a>
<br>A VERY interesting part about site tracking and elementary/intermediate stalking techniques
<br>
<hr>
<font color=blue><font size=+2>Anti-Cracking discussions</font></fonT>
<br><bR>
You may be interested in my <a href="couninte.htm">Counter Intelligence</a> page.

<hr size=3>

<font color=blue><font size=+2>Cracking discussions</font></fonT>
<br><bR>
You may be interested in my <a href="whydwcr.htm">Why crackers crack? (Reversing reversers' psychology)</a> 'late November' thread.
<hr size=3><a name="anchortric"></a>
<font color=blue><font size=+2>Tricks</font></fonT>

<br><bR><H2>
0. Most recent tricks!
</H2>
The following idea courtesy of Steven Martins<bR><br>"<font color=blue>
I used a function to check for SoftICE and it worked 
great. If the user had SoftICE loaded the program would use a different 
routine to generate the serial key. The cracker then thinks he found the 
correct code but on machines without SoftICE it's useless.</font>"

<hR>
<br><bR><H2>
1. Let's melt softice? Pro and contra
</H2>
Here you'll be able to check David Eriksson's original (Mid-97) <IMG SRC="../images/bulletr.gif" ALIGN=TOP WIDTH=13 HEIGHT=13 BORDER=0 VSPACE=0
HSPACE=0><a href="https://searchlores.nickifaulk.com/protec/meltice.c" tppabs="http://fravia.net/meltice.c">meltice</a>! A tool 
for detecting softice written in C, and here you'll have the same code ported  
by PhR to <IMG SRC="../images/bulletr.gif" ALIGN=TOP WIDTH=13 HEIGHT=13 BORDER=0 VSPACE=0
HSPACE=0><a href="https://searchlores.nickifaulk.com/protec/melticed.txt" tppabs="http://fravia.net/melticed.txt">Pascal/Delphi</a> (with Hoffmeister's corrections).<bR>
Anyway such an approach is of limited use. You may succeed in annoying some 
casual crackers, yet the fact that Numega chose to name their kernel
drivers that way doesn't mean much... 
there is nothing that prevents any reveser from renaming them...<br><bR>
So I publish the snippets above because this can give some ideas to good protectors. Go beyond 
and prepare some good code for Sice detection (or even some 'retaliating code'... come to 
think of it, if I were a protection scheme and if I would detect on a computer -say- 
softice, wdasm and 
smartcheck I would know that I should ring 
all possible defcom red alert bells... but READ (and head) THE FOLLOWING CAVEAT!<br><br>
First of all you should UNDERSTAND what Softice is... many 'sunday' programmers 
don't have the slightest clue...<br>
<br>
SoftICE is - same as WDEB386.EXE of Microsoft a completely different story,
from turbodebugger... 
much to shareware-authors and driver developers dismay.<br>First of all,

SoftICE is 
    started before Windows starts (more exactly - you run winice.exe and
winice in turn runs win.com).  This applies to win9x .
configured to run as a
    boot driver, kernel driver, or a dynamic loadable (kernel) driver under
NT.<br>
When the gui starts SI is already present and can be invoked via ALT-D
(preset). So there is no "present-not present" thing with softice, it sits
beneath windows and waits till you need it. as the bulk of softice consists
of ring 0 software, you're not limited in what you can view. driver writers
for that reason quite routinely start their machine with si present.
<br>
Therefore you go about detecting it like you'd detect any other vxd  - seeking the
VMM's DDB and then just walking the linked list of DDBs in the case of
Win9x, and examining the list of loaded drivers in NT.
<br>The problem rather
is, what are you going to do if you find it? Nuke the machine?<br>
The world
increasingly seems to fill up with authors, who think, just because somebody
(mostly by accident) installed one of their vanity proggies, they got the
right to nuke others peoples machines.<br>
As it's part of my job to work with
softice I just can't work with some programs without reversing them at 
the moment - o.k. so what, but what will annoy almost all VXD authors 
is if you just go about rebooting the machine if they start
your software... maybe putting a link into the autostart group before.
<br>
Therefore do me and people like me a favor please: forget 
that debugger detection
crap, do a little bit of math and firgure out how to en- and decrypt your
software at runtime (as it is to valuable to be looked at by other people),
be creative and contructive instead of just destructive.
<br><br>
Btw, there is no law against people debugging and reversing your 
software, as strange as this may seem to you, but there surely is a law 
against deliberatly risking to damage other peoples' property.

<br><br><a name="oldies"></a>
<center>

<table border=1 width=88%><tr><td bgcolor="#C6E7C6"><center><font
size=+3>Oldies (ancient tricks)</font></center></td></tr></table></center>


<hr width=33%><center><font size=+2><font color=red>
1994<bR></fonT></fonT>
<a href="inbarraz.txt">inbarraz.txt</a>: Anti Debugging Tricks<bR>
by Inbar Raz<br>Release 5, 
Preventive actions & Self-modifying code.
</center>
<br><br>

<hr width=33%><center><font size=+2><font color=red>
1993<bR></fonT></fonT>
<a href="razrefut.txt">razrefut.txt</a>: Anti Debugging Tricks<bR> by 
Michael Forrest<br>(Refers to Imbar Raz's release 1), 
Why Raz tricks don't work anymore in to-days debuggers world
</center>
<br><br>

<hr width=33%><center><font size=+2><font color=red>
1998<bR></fonT></fonT>
<a href="insi_faq.txt">insi_faq.txt</a>: "Insider FAQ"<bR> by 
Christoph Gabler<br> Source code galore: 
Anti Trace Code, Anti-AntiVirus Code, How to fool unpackers code.
</center>
<br><br>


<br><br>

<hr size=3>
<center>
<Font color=green>
(c) 1952-2032 <a href="../info.htm">Fravia</a>, All rights reserved</font>
<a name="exemp"></a>
<hr></center>

How to Obtain the Serial Number of a Drive... see <a href="protec.htm#anchorintro">introduction</a>
<font size=-1>
<pre>
Public Function VolumeSerialNumber(ByVal RootPath As String) As String
    Dim VolLabel As String
    Dim VolSize As Long
    Dim Serial As Long
    Dim MaxLen As Long
    Dim Flags As Long
    Dim Name As String
    Dim NameSize As Long
    Dim s As String
    If GetVolumeSerialNumber(RootPath, VolLabel, VolSize, Serial, MaxLen, Flags, Name, NameSize) Then
        'Create an 8 character string
        s = Format(Hex(Serial), "00000000")
       'Adds the '-' between the first 4 characters and the last 4 characters
        VolumeSerialNumber = Left(s, 4) + "-" + Right(s, 4)
    Else
        'If the call to API function fails the function returns a zero serial number
        VolumeSerialNumber = "0000-0000"
    End If
End Function
</pRE>
<hr>
</body>
</html>